## TLS

### TLS Handshake Process

1. 클라이언트가 client hello 메세지를 보낸다. 이때 메세지는 클라이언트가 어떤 TLS 버전을 지원하는지, 사이퍼 슈트는 어떤거 지원하는지, 그리고 client random이라고 알려진 랜덤한 문자열을 보낸다.
2. 클라이언트 헬로에 대한 응답으로 서버는 SSL 인증서, 선택한 사이퍼 슈트, 그리고 Server random을 보낸다.
3. 클라이언트는 CA에서 서버가 보낸 SSL 인증서를 검증한다. 이를 통해 서버가 진짜가 맞고, 클라이언트는 해당 도메인의 실제 소유자와 소통하고 있다는걸 보장 받는다.
4. 클라이언트는 premaster secret이라는 랜덤 문자열 하나를 더 보낸다. 이 premaster secret은 공개키에 의해 암호화 되고 오직 서버가 가진 개인키를 통해서만 복호화 가능하다.
5. 서버는 개인키로 premaster secret 복호화 한다.
6. 클라이언트와 서버는 클라이언트 랜덤과 서버 랜덤 그리고 premaster secret을 사용해서 세션 키를 만든다. 그것들은 같은 결과를 얻어야 한다.
7. 클라이언트는 세션 키로 암호화된 finishied 메세지 보낸다.
8. 서버도 세션 키로 암호화된 finished 메세지 보낸다.
9. 핸드쉐이크가 완료되면 커뮤니케이션은 세션 키를 통해 수행된다.

### Cipher Suite

```shell
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
```
최근에는 FS, PFS를 위해 RSA 키 교환 방식 대신 DECDHE를 많이 사용한다. 이 방식은 Client Key Exchange 과정에서 비밀키를 교환 안하기 때문에 서버 개인키 탈취되도 문제 없다.
서로 비밀키를 생성할때 필요한 파라미터만 교환

TLS Handshake가 생성한 잠재적인 지연을 완화하는 것을 돕는 기술이 있습니다.
하나는 TLS Handshake가 완료되기 전에 서버와 클라이언트가 데이터 전송을 시작하도록 하는 TLS False Start입니다.
TLS를 빠르게 하기 위한 또 다른 기술은 이전에 커뮤니케이션한 적이 있는 서버와 클라이언트가 간략화된 Handshake를 사용하도록 허용하는 TLS Session Resumption입니다.

TLS를 로딩 시간에 현저하게 영향을 미쳐서는 안 되는 매우 빠른 프로토콜로 만드는 데 도움을 주었습니다.
TLS와 연관된 계산 비용은 오늘날 표준에 따르면 거의 무시해도 좋은 정도입니다.

2018년에 발표된 TLS 1.3은 TLS를 더 빠르게 만들었습니다.
TLS 1.3의 TLS Handshake는 몇 밀리세컨드로 프로세스를 단축하며 2회 왕복 대신 1회 왕복(또는 왔다 갔다하는 커뮤니케이션)만을 요구합니다.
사용자가 전에 웹 사이트에 연결한 적이 있으면, TLS Handshake는 0회 왕복을 할 수 있으며, 이는 속도를 더 빠르게 할 수 있습니다.

- DNS 스푸핑 : 사용자의 DNS 캐시 정보를 변조 다른 IP로 전송
- DNS 하이재킹 : 사용자를 다른 DNS 서버로 보내버린다

### TLS 1.3 버전 특징
- TLS 핸드쉐이크 과정 단축, 기존에는 2 RTT 하던거 1RTT로 단축하고, 이전에 연결한 적 있으면 0 RTT로 단축
- 보안에 취약한 예전 암호화 알고리즘들 지원 중단


## mTLS

기존의 TLS 방식은 서버 측에만 TLS 인증서를 보관하고 클라이언트가 서버로부터 TLS 인증서를 받아 확인함으로써 신뢰성 있는 통신을 보장한다.
하지만 더 신뢰성 있는 통신을 위해서는 클라이언트도 검증해야 한다는 필요성이 생겼고, 클라이언트와 서버 모두가 TLS 인증서를 통해 서로를 인증하는 **mTLS** 방식이 생겨났다.
제로 트러스트 환경이 강조되면서 클라이언트가 본인을 검증된 사용자라는걸 증명할 필요가 생겼다.
mTLS에서는 클라이언트와 서버 모두에 인증서가 있고 양측 모두 공개/개인 키 쌍을 사용하여 인증한다. 일반 TLS와 비교하여 mTLS에는 양 당사자를 확인하기 위한 추가 단계가 있다.

1. 클라이언트가 서버에 연결
2. 서버가 TLS 인증서를 제시
3. 클라이언트가 서버의 인증서를 확인
4. 클라이언트가 TLS 인증서를 제시
5. 서버가 클라이언트의 인증서를 확인
6. 서버가 액세스 권한을 부여
7. 클라이언트와 서버가 암호화된 TLS 연결을 통해 정보를 교환

<img width="693" alt="스크린샷 2024-04-29 오후 3 57 19" src="https://github.com/CMC11th-Melly/Melly_Server/assets/82302520/a7040633-e2b5-4942-b7de-8fe6b5b524a1">

### 만약 클라이언트와 서버 사이에 WAF가 있다면?
보통 클라이언트와 서버 사이에 WAF가 들어오고, WAF가 클라이언트의 인증서를 검증한다. 서버는 WAF의 인증서를 검증
근데 WAF 통하면 서버가 클라이언트 식별 가능한가? 이때는 클라이언트 정보를 프록시 헤더에 넣어서 서버로 넘겨주면 식별 가능이다.

기존 TLS의 경우에는 클라이언트가 서버에 요청을 하면, 서버는 TLS 인증서를 클라이언트에게 전송해주고, 클라이언트가 확인한 뒤, 암호화된 연결을 통해서 정보 교환한다




